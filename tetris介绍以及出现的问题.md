# 游戏大厅  界面widgt

利用mysql服务器去记录登陆状态，打算游戏就设定在widgt里，而且要两列游戏，服务器实时播放两个人的游戏实况在同一个界面内



![image](https://user-images.githubusercontent.com/81805379/180161437-9812a9e5-238d-4b37-89dd-8120e831df5a.png)

![image](https://user-images.githubusercontent.com/81805379/180161668-1ebebd22-1a28-46d2-b82c-45916e023f82.png)

# 游戏分析

![image](https://user-images.githubusercontent.com/81805379/180215439-8d2cb486-aa01-4a3d-a46b-106a064f438a.png)

![image](https://user-images.githubusercontent.com/81805379/180594304-546c9ad6-2dc0-4fe3-957c-5dc71b42a4ea.png)

上面的UI是无法直接访问底层数据的，必须要经过中间这么一层一层的最后传输过去。

# 问：我为什么要写这么多类

答：选择模块化的设计思想，提高了代码的扩展性和维护能力，比如我想添加一个形状，我就再来一个形状的类，再一个，希望各个类之间不互相干扰。

# 功能总览

1. 图形放到棋盘上
2. 形状向下移动(自动)
3. 形状由键盘向左、右和下(加速)的移动
4. 形状的旋转
5. 棋盘上一行满，则消除
6. 计分，化作攻击子弹，由网络传输给另一名玩家
7. 被攻击玩家能否在5秒内通过消除等量子弹数的方块防御该次攻击
   1. 防御住 被攻击槽清零
   2. 没由防御住/防御住一部分，被攻击玩家的棋盘从下方随机长出被攻击子弹*行数的惩罚块

# 问:我为什么要先擦除颜色再移动

​	因为如果判定向一个方向移动，形状是会变化的，有的形状向Z S有变化形态，L和J由四种变化形态，如果每一个变化形态都写一个独立的变化判定方法，代码冗余且复用性不高。所以我们选择形状内所有方块全部判断，对方块的判断是下一个方向内是否有别的方块，以竖直形状的i举例，如果竖直的i下落，四个格子都要判断下面有没有其他颜色的格子来判断下面有没有其他方块，但如果不擦除颜色，竖直的i形状只有底部的下一个是真正的进行判断，其他方块的下一步都会碰到自己的颜色，所以先擦颜色，判断四个格子内的下一步是否与背景色相同，可以完全避免上述情况，等移动判定后，再恢复对应格子的颜色。

# 问：为什么开始游戏前要先要在next棋盘创建形状

因为主窗口是一直取得是下一个图形，没有下一个取不了，你不给它它没法走了 函数逻辑。

# 问：如何实现旋转的

![image](https://user-images.githubusercontent.com/81805379/180642703-5255801a-8379-40b4-8b04-cde091e11b0a.png)

每一个方块均以

# 项目bug：按下 “下”形状到底部后不变稳定

这是因为一直按下一直在处理下的事件，即使换成定时器也无法解决

### 解决方法：事件过滤和重写event()

event其实不好，

# 项目bug：按下下后 下了三个格子就停住了

原先用的方法是 信号槽的timer 然后通过事件对于下方向键的按下与抬起设定定时器的速率，来以另一种方式达到调节形状下落快慢，对于信号槽函数来讲，信号的特性是发射马上处理，而事件，是有它的消息队列的。它会先处理完前面的操作，然后进入按键按下的操作，所以先动了三个格子，然后因为是按住，所以卡在了那个事件里，和定时器冲突了

![image](https://user-images.githubusercontent.com/81805379/180967395-c5c524f6-507b-4e51-b472-fc862e8afd50.png)

### 解决方法：timeevent定时器

我通过两个不同的定时器id，来切换下落状态，反而解决了该问题。

# timeevent出现的问题：定时器id过多

如果不删掉前面的定时器id，他会一直涨下去，过多会导致卡死问题，所以我选择用两个变量记录两个定时器上一时刻的值，在按下后记录-starttimer-删掉记录值，这样的操作

# 为什么手写了一边TCP/UDP壳子而没有用QTCP呢？(采用中介者/代理模式的原因)

因为我希望我的网络类是纯C++写的，不只是放到当前的项目里，我放到别的项目里也能直接用，也就是**考虑多个项目平台且跨平台问题**，别的项目不一定是QT写的，所以也是采用中介者模式的原因，不让kernal(解析类)直接与我写的C++网络类做接触，所以我在网络类INet外面做了一层封装，即中介者/代理类。

![image](https://user-images.githubusercontent.com/81805379/181416897-4ce8871f-ea25-4fd6-8c3d-c96b98661ef4.png)

# 你如何将C++的网络模块导入QT呢(无法解析的外部符号)

按照传统的方法，肯定是把net文件和中介者文件考入到QT项目下，先QT+=network 即开启网络，而且还要再项目里的工程文件pro里添加路径：

![image](https://user-images.githubusercontent.com/81805379/181427146-7074342f-9a38-44d7-ae46-995a3d7c1522.png)

编译后会出现无法解析的外部符号，是因为：

![image](https://user-images.githubusercontent.com/81805379/181426949-7eb11997-396e-4151-879c-e21961de08cc.png)

所以，每一次装载库我都要去做这些操作，效率太低了，所以我把这些东西封装成为一个pri文件，每使用一个QT项目，只需要再对应项目里包含以下这个pri工程文件和该pri文件的路径，就可以了，很省事。

![image](https://user-images.githubusercontent.com/81805379/181427722-f7b6f871-638a-478d-832c-9cc6d546de02.png)

# 中介者干了啥

实际上中介者就是调用了底层的C++网络，并结合起QT特有的信号槽函数，来进行使用。

# 禁用奶狗算法，不让他合包，有啥发啥。

# 解决毡包问题的方法：先发大小，再发内容

但是也会引发另一个问题，如果普通的方法send一次，再send一次，发送是有可能多线程的，很可能会导致两个大小粘到一起两个内容粘到一起，为了避免多线程的发送问题，可以用锁解决，也可以把数据放到容器里一次发送过去，让他一点一点取，前四个字节给包大小，因为vector的空间是堆区的，特性是自动回收空间，不需要手动delete，而且vector自动扩容很方便。但是要注意send是阻塞发送，不要把包弄得太长，可以人为分包

# connect网络连接函数引发的问题

如果连接不上的话connect会阻塞当前进程，所以再使用的时候可以不用先OPENNet，先发送数据判断当前是什么样的连接状态。

# 对于处理函数有一个问题 信号和槽的机制之一： 非主线程是不能操作主界面的，那么如何写处理函数呢？

### 答

 在处理函数dealdata里面，将数据以自定义信号的方式发出去，这样的话在dealdata里就不需要调函数了

 Qemit 发射 (信号)

# 为什么使用update而不是repaint

![image](https://user-images.githubusercontent.com/81805379/181667855-91b88e02-e38d-45cb-b60a-99163246f11f.png)

# strongfocuspolicy

![image](https://user-images.githubusercontent.com/81805379/181672328-6ee9f791-8e42-42b0-aec2-d5bb3f558ad3.png)

# 为社么服务器socket一开始给0

0是INVALID_SOCKET，connect当然失败了，如果socket成功，返回的应该是大于0的SOCKET

# (未解答)问：为什么要把所有变量都写成私有的
