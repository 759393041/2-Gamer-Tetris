# Cell类 方格

背景板由许许多多的小格子组成，所以我们从由小到大开始设计。

## 类成员

```c++
class cell
{
    
    //类成员函数
public:
    cell() {}//构造函数
    cell(QPoint &, QPointF &, int _color = NO_COLOR);//重载构造函数，给方块的两个坐标和颜色赋值
    cell(const cell& c) { copy(c); }//拷贝构造
    //操作函数：
    cell& copy(const cell&);//方块拷贝
    cell& operator=(const cell& c) { return copy(c); }//方块拷贝，但是是重载操作符
    void set_color(int _color) { color = _color; }//设置方块的颜色
    QColor draw_cell_color() const;//根据类内的color 给颜色，所以不用参数
    int get_color() { return color; }//读取方块颜色
    QPointF& get_position() { return position_on_window; }//读取当前方块在窗口上的位置
    QPoint& get_location() { return location_on_board; }//读取当前方块在棋盘(格格)上的位置
    
    //类成员变量
private:
    QPointF position_on_window;//方块在窗口上的位置
    QPoint location_on_board;//方块在棋盘(格格)上的位置
    int color;//方块的颜色

};
```

cell虽然是棋盘上的格子，但也是存在于窗口内的，所以需要两个坐标:

一个用于记录方格的左上角的坐标，也就是**方格在窗口内的坐标**：

QPointF position_on_window；**(f是浮点数，窗口的坐标是小树的x和y)**

一个用于记录方格在棋盘中是哪一个格子的坐标

QPoint location_on_board;

还有一个是记录方格本身的颜色，颜色想要用宏替换的方法去存储颜色种类，利于后面用switch case给方格绘图染色用：

int color;

## 源程序实现

### 有参构造

参数:QPoint &, QPointF &, int _color = NO_COLOR

给类内方块在窗口上的位置和方块在棋盘(格格)上的位置赋初值，一个为Qpoint类型，一个为Qpointf类型，默认为无背景颜色

### 拷贝构造

### 深拷贝

参数：const cell& c

相关函数：copy()函数与重载操作符=

操作：

1. 将外部变量cell的成员变量值赋给类内cell的变量
2. 返回类内成员的地址

### 返回当前cell的颜色

draw_cell_color()

根据cell对象里的color，来决定返回什么颜色的QColor，用于染色

操作：

1. 创建Qcolor类对象
2. 根据cell类内成员color进行switch-case选择颜色分支，并根据颜色分支调用Qcolor类对象的有参初始化去赋值Qcolor颜色，其中color为整形，可以通过宏定义替换的方式为switch-case进行选择。
3. 返回已赋值的qcolor类对象

### 设定方块颜色

# Board类 背景

board由cell组成

## 类成员

```c++
class board
{
//类成员函数
public:
    board(){}
    board(int, int, int, int);//有参构造，赋值类成员变量
    board(const board& bd) { copy(bd); }//有参构造，参数为另一个类对象
    cell& get_a_cell(int, int) const;//创建背景
    void clear_board();//清空背景板
    void set_cell_color(cell &, int);//设定目标格子颜色
    int get_cell_color(cell &);//获得背景中目标格子的颜色
    bool is_full(int);//判断一行是否满了
    bool is_empty(int);//判断一行是否是空的
    bool is_something(int);//判断一行是否有东西
    void clear_row(int);//清空这一行
    void row_cut_paste(int from,int to);//把这行从from行整体移动到to行(所以类似于裁剪)
    const QPoint get_start_location(int, int, int);//获取在棋盘上开始的位置
    board& operator=(const board& bd) { return copy(bd); }
    ~board();
private:
    board& copy(const board&);
    
//类成员变量
private:
    cell *board_space;//背景数组
    int board_h;//背景高度
    int board_w;//背景宽度
};

```

## 源程序实现

### 有参构造

参数：x，y两个窗口坐标，窗口宽，窗口高。

int x, int y, int board_height, int board_width

操作:

1. 窗口宽、高赋值给类内成员w、h

2. 在堆区new一个细胞数组给类内成员，即给背景开辟空间

3. 循环初始化背景板:

   1. 计算出当前格子在窗口上的坐标,即：

      ```c++
      float _x = float(w) * float(CELL_LENGTH) + float(x);
      float _y = float(h) * float(CELL_LENGTH) + float(y);
      //这个w和h用于循环体中的循环变量，就是记录细胞的行与列数，
      ```

   2. 创建关于背景板中当前格子在背景板上的坐标Qpoint对象和格子在窗口上的坐标Qpointf对象，并将刚才的结果进行赋值。

   3. 对当前背景板坐标下的cell格子进行有参初始化，即第二部的两个类对象作为变量输入。

   4. 如此循环至board中每一个空间cell都初始化了。

一维数组不是二维数组，但依旧是连续空间，对齐取下标的算法为：

```c++
 board_space[h * board_width + w] = cell(location_on_board, position_on_window);
```

### 清空背景板颜色

操作：

1. 遍历背景类成员变量board_space，细胞空间。
2. 调用setcolor设置颜色为无颜色。

### 设定背景板中方块的颜色

参数：目标细胞cell& _cell，整型的颜色(宏替换)int _color

操作：

1. 记录目标细胞的x与背景板宽度相乘在加上y坐标
2. 将该记录作为细胞空间数组下标索引，并调用该索引下细胞的设定方块颜色函数

实际上获取背景板的变量都是这么索引的，只不过操作不一样，搜索是一样的。

### 判断某一行是否满

参数：int行数

操作：

1. 创建计数变量，用于记录同行内有颜色的方块数量
2. 循环通过对board内细胞空间目标行数那一行进行判断，调用getcolor函数，若颜色不等于NOcolor，计数器++；
3. 返回时如果count计数器与背景的宽度相同，返回真，否则返回假。

### 判断某一行是否空

参数:int num，判断num那一行

与上一步相似，不过在第二部的判断里，若颜色等于NOcolor 计数器++；如果计数器等于背景宽度，那就是空，反之为假。

### 判断否一行是否有格子

参数:int num，判断num那一行

不满也不空，那就是有被。

```C++
    return (!is_empty(num) && !is_full(num));
```

### 清空这一行

参数:int num ，num为想要清空的那一行的标号

把那一行颜色变回NOcolor就完事了

操作：

1. 遍历背景空间的那一行
2. 对同行的每一个元素调用setcolor函数并设置成无颜色

### 方块整行移动(把某一行移动至另一行)

参数：int from, int to

操作:

1. 遍历背景空间的一行
2. 记录源行的颜色
3. 目标行变成源行的颜色
4. 源行变为无色

因为是一行一行的，不是整体的，具体变哪行是游戏引擎的事。

### 深拷贝

参数:const board&bd

变量赋值，给类成员变量背景空间开辟空间，然后将源背景赋值给类成员背景空间，而不是让两个变量的空间指向同一个堆区空间。

### 根据形状获取起始位置

每个方块的形状各不相同，所有起始坐标的位置也不相同。

采用switch-case和宏替换的方式来根据不同的形状选择不同的位置

同时也要注意，游戏内是有两个背景的，一个背景显示游戏界面，一个显示下一个方块。

所以参数：int 形状(宏替换)，int 水平格式，int 竖直格式

如果参数输入的水平格式是居中，竖直格式也是居中，那就是放到小背景板的

如果水平格式是居中，但竖直不是，那就是放到大背景板的

采用这样的方法，根据每个形状的起始位置偏差不一样，记录其初始位置。

并返回一个Qpoint(起始x，起始y)的坐标类对象。

### 析构

不要忘了回收背景空间的堆区空间

# shape类 形状

形状也是由方格组成

## 类成员

```c++
class shape
{

//类成员函数
public:
    shape(cell &, board& bd);//初始化形状
    virtual ~shape() = 0;
    virtual void rotate();//形状旋转函数
    int get_color() { return color; }
    cell& get_a_cell(int n) { return cells[n]; }
    void set_a_cell(int n, cell& _cell) { cells[n] = _cell; }//设置方块

    //疑问 是否需要加入染色操作函数
    //答案 不需要，在构造的时候就可以给了，而且还有继承

protected:
    virtual void compute_rotate_positions();//实际上计算的是以谁为为中心转，二维数组中四个形态中旋转中心块那一列是不变的。
    //这函数就是为了写死那个中心，但每个块转的中心都不一样，所以一个父类，其他的重写。
    
    //类成员变量
    bool is_vaild_position(int);
    int color;//形状的颜色 每个形状颜色各不相同
    cell cells[NUM_OF_CELLS];//形状的空间
    QPoint rotate_positions[NUMBER_OF_ROTATE_POSITIONS][NUM_OF_CELLS];//以二维数组来记录每一个形状内方块旋转后的坐标位置
    int which_position;    //Which position的意思是我旋转了多少下。也就是按了多少次上
    //对它取余4不久是能确定转的形态是0/1/2/3哪种么 :)
    board m_bd;
};

```

## 源程序

### 有参构造

无论是啥**形状**，都由**四个方块**组成，是肯定要开辟空间的。

参数:第一个位置的方块cell& first_cell，放入的背景板 board& bd

操作:

1. 给定颜色，并初始化为无颜色；将参数传入类内背景板，用于记录这个形状是放在哪个背景里的
2. 遍历并为形状的每一个单元初始化方块
3. 将形状的空间数组首元素给予第一个位置的方块信息
4. 旋转位置初始化为0

### 计算旋转中心的位置

​	每一个形状的旋转位置各不相同，所以该函数写成了虚函数，将7个形状均继承父类形状，其中子类重写父类的计算旋转中心位置函数。

思路：我们自行选择，固定住形状中四个方块的一个方块，就是以每一个形状数组第二个下标的方块为固定位置，但固定位置的坐标我们自己选择

因为旋转时，只有中心位置的坐标是永远不会变的。

操作:

1. 记录旋转中心的坐标x与y
2. 以旋转中心的坐标x与y为基准，计算出该形状其他方块旋转后的位置，并记录在旋转坐标二维数组内。

这个函数需要子类中实现，并且7个子类形状的旋转后位置坐标是各不相同的。

### 是否能旋转

参数：int which_position 下一个旋转形态

操作:

1. 根据下一个which_position形态编号去遍历二维数组rotate_positions的一列坐标
2. 对这个形态的每一个方块的坐标进行判断：
   1. 是否横纵坐标>0
   2. 横纵坐标是否<背景板边界
   3. 遍历的这一组坐标下的方格是否为无颜色
3. 满足则返回true，否则返回false 并给类内旋转许可标志is_vaild赋对应的值。

### 旋转操作

通过对which_position进行取余4的操作，得到0123四个形态，对应旋转的四个形态。

无参数

操作:

1. 计算旋转的位置
2. 记录旋转的次数
3. 对旋转次数取余获得下一个旋转的形态编号
4. 预先对旋转后的位置做判断：调用旋转判断函数is_vaild_position 利用其返回值真假判断
5. 能转的话，从形状坐标二维数组中提出每个方块的横纵坐标作为参数，输入背景板方格的获得方块函数get_a_cell，返回值输入给形状空间数组cells；如果转不了，旋转次数回退-1

染色不在这里染色，这里只是找到旋转后的空间，这么做的原因在游戏引擎里细讲。

# 7个形状子类

以Z型为例，所有形状与之拥有相同的类成员

## 类成员

```c++
class zshape:public shape
{

public:
    zshape(cell &, board &);//有参构造函数，给继承的两个参数赋值
    ~zshape();

private:
    virtual void compute_rotate_positions() override;
};
```

计算旋转坐标的函数操作方法与父类里写的默认操作一致，但是要根据每个形状自己去设定。

# 游戏引擎类
