# Cell类 方格

背景板由许许多多的小格子组成，所以我们从由小到大开始设计。

## 类成员

```c++
class cell
{
    
    //类成员函数
public:
    cell() {}//构造函数
    cell(QPoint &, QPointF &, int _color = NO_COLOR);//重载构造函数，给方块的两个坐标和颜色赋值
    cell(const cell& c) { copy(c); }//拷贝构造
    //操作函数：
    cell& copy(const cell&);//方块拷贝
    cell& operator=(const cell& c) { return copy(c); }//方块拷贝，但是是重载操作符
    void set_color(int _color) { color = _color; }//设置方块的颜色
    QColor draw_cell_color() const;//根据类内的color 给颜色，所以不用参数
    int get_color() { return color; }//读取方块颜色
    QPointF& get_position() { return position_on_window; }//读取当前方块在窗口上的位置
    QPoint& get_location() { return location_on_board; }//读取当前方块在棋盘(格格)上的位置
    
    //类成员变量
private:
    QPointF position_on_window;//方块在窗口上的位置
    QPoint location_on_board;//方块在棋盘(格格)上的位置
    int color;//方块的颜色

};
```

cell虽然是棋盘上的格子，但也是存在于窗口内的，所以需要两个坐标:

一个用于记录方格的左上角的坐标，也就是**方格在窗口内的坐标**：

QPointF position_on_window；**(f是浮点数，窗口的坐标是小树的x和y)**

一个用于记录方格在棋盘中是哪一个格子的坐标

QPoint location_on_board;

还有一个是记录方格本身的颜色，颜色想要用宏替换的方法去存储颜色种类，利于后面用switch case给方格绘图染色用：

int color;

## 源程序实现

### 有参构造

给类内方块在窗口上的位置和方块在棋盘(格格)上的位置赋初值，一个为Qpoint类型，一个为Qpointf类型，默认为无背景颜色

### 拷贝构造

### 深拷贝

相关函数：copy()函数与重载操作符=

操作：

1. 将外部变量cell的成员变量值赋给类内cell的变量
2. 返回类内成员的地址

### 返回当前cell的颜色

draw_cell_color()

根据cell对象里的color，来决定返回什么颜色的QColor，用于染色

操作：

1. 创建Qcolor类对象
2. 根据cell类内成员color进行switch-case选择颜色分支，并根据颜色分支调用Qcolor类对象的有参初始化去赋值Qcolor颜色，其中color为整形，可以通过宏定义替换的方式为switch-case进行选择。
3. 返回已赋值的qcolor类对象

### 设定方块颜色

# Board类 背景

board由cell组成

## 类成员

```c++
class board
{
//类成员函数
public:
    board(){}
    board(int, int, int, int);//有参构造，赋值类成员变量
    board(const board& bd) { copy(bd); }//有参构造，参数为另一个类对象
    cell& get_a_cell(int, int) const;//创建背景
    void clear_board();//清空背景板
    void set_cell_color(cell &, int);//设定目标格子颜色
    int get_cell_color(cell &);//获得背景中目标格子的颜色
    bool is_full(int);//判断一行是否满了
    bool is_empty(int);//判断一行是否是空的
    bool is_something(int);//判断一行是否有东西
    void clear_row(int);//清空这一行
    void row_cut_paste(int from,int to);//把这行从from行整体移动到to行(所以类似于裁剪)
    const QPoint get_start_location(int, int, int);//获取在棋盘上开始的位置
    board& operator=(const board& bd) { return copy(bd); }
    ~board();
private:
    board& copy(const board&);
    
//类成员变量
private:
    cell *board_space;//背景数组
    int board_h;//背景高度
    int board_w;//背景宽度
};

```

## 源程序实现

### 有参构造

参数：x，y两个窗口坐标，窗口宽，窗口高。

操作:

1. 窗口宽、高赋值给类内成员w、h

2. 在堆区new一个细胞数组给类内成员，即给背景开辟空间

3. 循环初始化背景板:

   1. 计算出当前格子在窗口上的坐标,即：

      ```c++
      float _x = float(w) * float(CELL_LENGTH) + float(x);
      float _y = float(h) * float(CELL_LENGTH) + float(y);
      //这个w和h用于循环体中的循环变量，就是记录细胞的行与列数，
      ```

   2. 创建关于背景板中当前格子在背景板上的坐标Qpoint对象和格子在窗口上的坐标Qpointf对象，并将刚才的结果进行赋值。

   3. 对当前背景板坐标下的cell格子进行有参初始化，即第二部的两个类对象作为变量输入。

   4. 如此循环至board中每一个空间cell都初始化了。

一维数组不是二维数组，但依旧是连续空间，对齐取下标的算法为：

```c++
 board_space[h * board_width + w] = cell(location_on_board, position_on_window);
```

### 清空背景板颜色

操作：

1. 遍历背景类成员变量board_space，细胞空间。
2. 调用setcolor设置颜色为无颜色。

### 设定背景板中方块的颜色

参数：目标细胞，整型的颜色(宏替换)

操作：

1. 记录目标细胞的x与背景板宽度相乘在加上y坐标
2. 将该记录作为细胞空间数组下标索引，并调用该索引下细胞的设定方块颜色函数

实际上获取背景板的变量都是这么索引的，只不过操作不一样，搜索是一样的。

### 判断某一行是否满

参数：int行数

操作：

1. 创建计数变量，用于记录同行内有颜色的方块数量
2. 循环通过对board内细胞空间目标行数那一行进行判断，调用getcolor函数，若颜色不等于NOcolor，计数器++；
3. 返回时如果count计数器与背景的宽度相同，返回真，否则返回假。

### 判断某一行是否空

与上一步相似，不过在第二部的判断里，若颜色等于NOcolor 计数器++；如果计数器等于背景宽度，那就是空，反之为假。

### 判断否一行是否有格子

不满也不空，那就是有被。

```C++
    return (!is_empty(num) && !is_full(num));
```

### 清空这一行

把那一行颜色变回NOcolor就完事了

操作：

1. 遍历背景空间的那一行
2. 对同行的每一个元素调用setcolor函数并设置成无颜色

### 方块整行移动(把某一行移动至另一行)

操作:

1. 遍历背景空间的一行
2. 记录源行的颜色
3. 目标行变成源行的颜色
4. 源行变为无色

因为是一行一行的，不是整体的，具体变哪行是游戏引擎的事。

### 深拷贝

变量赋值，给类成员变量背景空间开辟空间，然后将源背景赋值给类成员背景空间，而不是让两个变量的空间指向同一个堆区空间。

### 根据形状获取起始位置

每个方块的形状各不相同，所有起始坐标的位置也不相同。

采用switch-case和宏替换的方式来根据不同的形状选择不同的位置

同时也要注意，游戏内是有两个背景的，一个背景显示游戏界面，一个显示下一个方块。

所以参数：int 形状(宏替换)，int 水平格式，int 竖直格式

如果参数输入的水平格式是居中，竖直格式也是居中，那就是放到小背景板的

如果水平格式是居中，但竖直不是，那就是放到大背景板的

采用这样的方法，根据每个形状的起始位置偏差不一样，记录其初始位置。

并返回一个Qpoint(起始x，起始y)的坐标类对象。

### 析构

不要忘了回收空间
