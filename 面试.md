# 俄罗斯方块对战游戏

## 介绍

我的第一个项目是俄罗斯方块对战游戏，游戏的原型和灵感来源于2019年任天堂公司switch平台推出的puyopuyo Tetris和Tetris99游戏。

当然项目先从需求，即游戏规则开始,规则为：在两名玩家登陆游戏后，可以选择开始俄罗斯方块游戏对战游戏。与传统竞速俄罗斯方块不同的是，每名玩家都可以通过消除俄罗斯方块来获得攻击点数，自动发起对另一名玩家的单次攻击，被攻击玩家可以在几秒内通过消除俄罗斯方块来自动防守该次攻击，若有玩家发动攻击，被攻击者的方块区域底部会生长出可以消除的惩罚块，如此往复直至一名玩家的方格顶出屏幕上方，游戏结束。

## 框架

首先我们需要一个棋盘为各种各样的形状去提供空间，而棋盘和形状都是由一个个方格组成的。

根据这样的需求，我们建立了三个类：方格类、形状类、棋盘类

### 方格

我们先谈一谈方格的需求，方格若想要显示在窗口上，需要为绘图事件提供坐标告诉他往哪里画矩形方块,也需要记录方格在棋盘(棋盘是个组件frame)上的位置，从而为这个方格在颜色变化的时候只需找到标号更改方格内村粗的颜色变量即可。

根据以上需求，建立类成员变量:

1. 每一个格子在棋盘(组件frame)上的位置
2. 每一个格子在窗口上的坐标
3. 方格自身的颜色

​	因为窗口坐标是浮点数要注意用QpointF

​	**因为觉得每次给Qcolor变颜色调用setRGB去调色很麻烦**还要一个一个一个给R,G,B数，不如就把颜色设为int类型，将七种颜色标码用宏替换，将其作为参数写入类内函数，让其函数根据选择语句if或者switchcase去返回对应颜色的Qcolor，这样使用更方便。

​	解决方案:建立了类成员函数

1. 根据类成员color获取方格颜色函数

​	**追加需求1**-背景板:因为背景板和形状需要一直存在在几盘，形状进入棋盘无论怎么样它落下后都会一直存在棋盘里，而棋盘更是从程序启动的时候就存在，所以需要用堆区空间，而后续的操作中是有方格之间的复制的，而对于堆区空间的复制会出现浅拷贝的情况，单纯的把堆区地址给了另一个指针导致一个空间回收了两遍编辑器崩溃。

​	解决方案:建立了类成员函数

2. 深拷贝函数，再开一块空间，进行方格内数据的赋值。

### 形状

​	需求：俄罗斯方块游戏中一共有7个形状，每个形状的颜色各不相同，每个形状的旋转中心各不相同，需要知道自己旋转后形状内各个方格的坐标以显示在背景板上，相应的也需要知道自己能否旋转、旋转后处于哪个形态，需要记录自己的旋转中心是形状中的哪个方格,需要记录每个形状的颜色。



​	根据以上需求,建立如下类成员变量：

 	1. 需要显示形状的背景板
 	2. 组成形状方格的空间(形状就四个格子)
 	3. 用一个4×4的二维数组记录每一个形状四个形态的坐标
 	4. 记录当前旋转形态的标号,采用宏替换的方式记录四个形态
 	5. 记录形状的颜色

​	因为每个形状各不相同，所以必须要有7个子类去继承父类去重写。

​	**根据每个形状的旋转中心，旋转位置各不相同，所以每个子类函数都要重写父类的旋转后形状坐标记录函数接口。**

​	1.解决方案:建立了类成员函数

​	该函数记录形状每个形态下各个方格在背景frame上的坐标，并返回给类内成员的4x4二维数组

​	**根据需要判断能否旋转的需求**

​	2.解决方案:建立了类成员函数

对这个形态的每一个方块的坐标进行判断：

1. 是否横纵坐标>0
2. 横纵坐标是否<背景板边界
3. 遍历的这一组坐标下的方格是否为无颜色