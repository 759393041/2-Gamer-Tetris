# 俄罗斯方块对战游戏

## 介绍

我的第一个项目是俄罗斯方块对战游戏，游戏的原型和灵感来源于2019年任天堂公司switch平台推出的puyopuyo Tetris和Tetris99游戏。

当然项目先从需求，即游戏规则开始,规则为：在两名玩家登陆游戏后，可以选择开始俄罗斯方块游戏对战游戏。与传统竞速俄罗斯方块不同的是，每名玩家都可以通过消除俄罗斯方块来获得攻击点数，自动发起对另一名玩家的单次攻击，被攻击玩家可以在几秒内通过消除俄罗斯方块来自动防守该次攻击，若有玩家发动攻击，被攻击者的方块区域底部会生长出可以消除的惩罚块，如此往复直至一名玩家的方格顶出屏幕上方，游戏结束。

## 框架

首先我们需要一个棋盘为各种各样的形状去提供空间，而棋盘和形状都是由一个个方格组成的。

根据这样的需求，我们建立了三个类：方格类、形状类、棋盘类

### 方格

我们先谈一谈方格的需求，方格若想要显示在窗口上，需要为绘图事件提供坐标告诉他往哪里画矩形方块,也需要记录方格在棋盘(棋盘是个组件frame)上的位置，从而为这个方格在颜色变化的时候只需找到标号更改方格内村粗的颜色变量即可。

根据以上需求，建立类成员变量:

1. 每一个格子在棋盘(组件frame)上的位置
2. 每一个格子在窗口上的坐标
3. 方格自身的颜色

​	因为窗口坐标是浮点数要注意用QpointF

​	**因为觉得每次给Qcolor变颜色调用setRGB去调色很麻烦**还要一个一个一个给R,G,B数，不如就把颜色设为int类型，将七种颜色标码用宏替换，将其作为参数写入类内函数，让其函数根据选择语句if或者switchcase去返回对应颜色的Qcolor，这样使用更方便。

​	解决方案:建立了类成员函数

1. 根据类成员color获取方格颜色函数

​	**追加需求1**-背景板:因为背景板和形状需要一直存在在几盘，形状进入棋盘无论怎么样它落下后都会一直存在棋盘里，而棋盘更是从程序启动的时候就存在，所以需要用堆区空间，而后续的操作中是有方格之间的复制的，而对于堆区空间的复制会出现浅拷贝的情况，单纯的把堆区地址给了另一个指针导致一个空间回收了两遍编辑器崩溃。

​	解决方案:建立了类成员函数

2. 深拷贝函数，再开一块空间，进行方格内数据的赋值。

### 形状

​	需求：俄罗斯方块游戏中一共有7个形状，每个形状的颜色各不相同，每个形状的旋转中心各不相同，需要知道自己旋转后形状内各个方格的坐标以显示在背景板上，相应的也需要知道自己能否旋转、旋转后处于哪个形态，需要记录自己的旋转中心是形状中的哪个方格,需要记录每个形状的颜色。



​	根据以上需求,建立如下类成员变量：

 	1. 需要显示形状的背景板
 	2. 组成形状方格的空间(形状就四个格子)
 	3. 用一个4×4的二维数组记录每一个形状四个形态的坐标
 	4. 记录当前旋转形态的标号,采用宏替换的方式记录四个形态
 	5. 记录形状的颜色

​	因为每个形状各不相同，所以必须要有7个子类去继承父类去重写。

​	**根据每个形状的旋转中心，旋转位置各不相同，所以每个子类函数都要重写父类的旋转后形状坐标记录函数接口。**

​	1.解决方案:建立了类成员函数

​	该函数记录形状每个形态下各个方格在背景frame上的坐标，并返回给类内成员的4x4二维数组

​	**根据需要判断能否旋转的需求**

​	2.解决方案:建立了类成员函数

对这个形态的每一个方块的坐标进行判断：

1. 是否横纵坐标>0
2. 横纵坐标是否<背景板边界
3. 遍历的这一组坐标下的方格是否为无颜色

并根据调节返回真假。

至于旋转行为的操作，属于对形状的移动，我这里交给了游戏引擎去写，因为对形状的旋转和对形状的下落操作有相似的地方(后面再讲)，且游戏引擎的作用就是管理棋盘、形状、方格之间的关系，比如形状在棋盘上的移动、旋，所以就需要一个控制台一样的东西操控这三个类，也是游戏引擎存在的必要性。

所以我不在这里写旋转具体操作。

### 背景板

需求：背景板需要给背景板上的方块开辟空间，所以需要记录背景板的高度和宽度。

​	那就给他开空间，给他整数类型的宽和高

**类成员变量**:

1. 背景方块空间
2. 背景高度
3. 背景宽度

注意：

​	因为背景方块空间是堆区的，需要避免浅拷贝问题。解决方法依旧是**深拷贝**

操作需求:

​	实际上在放开开始进入背景板是存在着这样的需求：**7个形状的方块起始位置是不一样的**。

​	因为我对形状初始化的时候，都是从背景板里选一个方块作为基准并把坐标赋值给形状，通过其背景板内相邻的方块的坐标，给这个形状其余的坐标赋值。

​	所以要写一个类成员函数，根据7个形状设定一个选择语句，返回一个Qpoint整数坐标作为形状类四个方块中，你选定的第一给方块作为初始化坐标。

​	而且我这个游戏里是有next背景板显示着下一个方块的，在右上角小背景板。next背景板内形状的起始坐标是和主背景板不一样的，要水平居中和竖直居中，而主背景板只要水平居中即可，竖直为0。

​	所以我不仅要设定好主背景板的起始坐标，我也要在7个形状的选择语句里继续判断，赋值的是主背景板还是next背景板。用个宏定义就可以，这个不难。

​	如果方块下落了，是**需要判断是否满格的**，满格是需要消除这一行，然后把剩余的有块的行，整体向下补齐。

​	需要**判断是否下一行是空的**，空的的话就可以继续下落直至背景板边缘

​	需要判断是否有其他颜色的方块存在，存在的话就不能下落/旋转之类的操作

​	所以三个逻辑函数bool类型的

1. 判断一行是否满了
2. 判断一行是否是空的
3. 判断一行是否有东西

实际上就是根据行号，遍历那一行，看有没有颜色即可，有东西的判断就是不满也不空被。

​	**根据行里方格满了的这个情况**，实际上是分为两步操作的：

1. 清空这一行，所有颜色变无颜色就行
2. 把某一行整体移动至零一行

具体移动到哪里，是游戏引擎里的判断，这里只是提供单纯对于背景内的操作。

**根据有重新开始游戏这个需求**(打完一盘了想要下一盘)，需要清空整个背景板，所以需要一个**类成员函数**

​	去将背景板上所有方格的颜色设置为无颜色

### 游戏引擎

游戏引擎要做的事一共分为：在背景中添加形状，控制形状移动与旋转，满行后调整残留方块并计算分数，判定游戏是否结束

​	在背景中添加形状，则需要两个背景板变量，一个主面板，一个next面板，添加形状，就需要一个形状指针，注意next下一个形状是随机的，而主面板要添加的形状是next里显示的，所以需要一个形状堆区空间去追踪next里的形状，以放边在主面板中添加。

​	添加形状也是用父类指针指向子类来实现多态的，而根据起始坐标的不同来区分放入的是主面板还是next面板

​	表面是放入形状，实际操作起始就是申请个空间给形状，初始化确定形状的坐标，这个坐标起始就是对应背景板的坐标，改个颜色，他就亮了，当然这个跟后面的绘画事件有关。

​	**然后这部分的核心是：控制旋转和控制下落**

无论是旋转还是下落，都是形状的运动。每一次运动前都需要判断能否运动，在判断这里，比如往下落，形状是需要预先判断下落后的位置是否有方块的，然后才能下落，**但会存在一个问题，如果对形状运动后所有的位置一起判断，比如L，L中只有底部的横条格下方是无颜色，竖条部分若进行判断，会有形状内其他方格的颜色干扰了判断。**而如果要按格子一个一个判断然后一个一个动，十分的麻烦属于暴力解决方法，而且形状是会变化的，每一个形状写一个对应的旋转和运动方格判定，这个工作量太大了。

​	我采用的解决方法：首先消除形状的颜色为背景色(无颜色)，然后再判定运动后的位置，若没超过边框且无颜色，则可以继续运动，如果是旋转的话，则根据形状类内记录的四个形态旋转后坐标二维数组进行判断即可。

​	
